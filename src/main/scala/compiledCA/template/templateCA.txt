package compiledCA;

import compiler.Locus;
import scala.collection.immutable.List;
import simulator.CAloops;
import simulator.CAloops2;
import simulator.PrShift;
import java.util.ArrayList;
import java.util.HashMap;
import static compiledMacro.RedS.*;
import static simulator.Util.*;

public final class {{NAMECA}}CA implements CAloops2 {
    public int CAmemWidth() {  return {{MEMWIDTH}};    }
    {{DECLNAMED}};
   {{DECLNOTNAMED}};
   public int[][]mem; //we will need to access the whole memory



public void anchorFieldInMem(int[][] m) {
  //global variables
  {{ANCHORNAMED}}
  {{ANCHORNOTNAMED}}
  mem=m;
}


@Override
public HashMap<String, List<Integer>> fieldOffset() { //for layer's initialization and update, as well as displayed fields.
   HashMap<String, List<Integer>> map = new HashMap<>();
   {{FIELDOFFSET}}
   return (map);
}



@Override
public ArrayList<String> theLoops(PrShift p) {
ArrayList<String> bugs=new ArrayList<>();
{{LISTCALL}}
return bugs;
}

@Override
public HashMap<String, Locus> fieldLocus() {
   HashMap<String, Locus> map = new HashMap<>();
   {{FIELDLOCUS}};
   return (map);
}


@Override
public HashMap<String, Integer> fieldBitSize() {
    HashMap<String, Integer> map = new HashMap<>();
    {{BITSIZE}}
    return (map);
    }

@Override
 public String displayableLayerHierarchy() {
    return "{{DISPLAYABLE}}";
}

@Override
public HashMap<String, String> init() {
    HashMap<String, String> map = new HashMap<>();
    {{INITLAYER}}
     return (map);
}

{{ANONYMOUSLOOP}}
}
